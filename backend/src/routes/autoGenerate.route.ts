/**
 * Route pour la g√©n√©ration automatique de planning hebdomadaire
 * 
 * Cette route utilise le service generatePlanning() avec moteur personnalis√©
 * pour cr√©er automatiquement un planning optimal en respectant
 * les contraintes et pr√©f√©rences des employ√©s.
 * 
 * @route POST /api/schedules/auto-generate
 * @access Private (authentification requise)
 * @author SmartPlanning Team
 * @version 1.0.0
 */

import express, { Response } from 'express';
import { z } from 'zod';
import mongoose from 'mongoose';
import authenticateToken, { AuthRequest } from '../middlewares/auth.middleware';
import { generatePlanning } from '../services/planning/generateSchedule';
import GeneratedScheduleModel from '../models/GeneratedSchedule.model';
import { cacheService, CacheKeyType, CacheHelpers } from '../services/cache.service';

// Cr√©ation du router Express
const router = express.Router();

/**
 * Sch√©ma de validation Zod pour la requ√™te de g√©n√©ration de planning
 * Valide la structure et les types des donn√©es d'entr√©e
 */
const planningRequestSchema = z.object({
  weekNumber: z.number().min(1).max(53).int('Le num√©ro de semaine doit √™tre un entier'),
  year: z.number().min(2023).max(2030).int('L\'ann√©e doit √™tre un entier'),
  employees: z.array(z.object({
    _id: z.string().min(1, 'L\'ID employ√© est requis'),
    contractHoursPerWeek: z.number().min(1).max(60, 'Les heures contractuelles doivent √™tre entre 1 et 60'),
    exceptions: z.array(z.object({
      date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Le format de date doit √™tre YYYY-MM-DD'),
      type: z.enum(['vacation', 'sick', 'unavailable', 'training', 'reduced'], {
        errorMap: () => ({ message: 'Type d\'exception invalide' })
      }),
    })).optional(),
    preferences: z.object({
      preferredDays: z.array(z.string()).optional(),
      preferredHours: z.array(z.string().regex(/^\d{2}:\d{2}-\d{2}:\d{2}$/, 'Format horaire invalide (HH:MM-HH:MM)')).optional(),
      allowSplitShifts: z.boolean().optional()
    }).optional(),
    restDay: z.string().optional()
  })).min(1, 'Au moins un employ√© est requis'),
  companyConstraints: z.object({
    openDays: z.array(z.string()).optional(),
    openHours: z.array(z.string().regex(/^\d{2}:\d{2}-\d{2}:\d{2}$/, 'Format horaire invalide (HH:MM-HH:MM)')).optional(),
    minEmployeesPerSlot: z.number().min(0).optional(),
    maxHoursPerDay: z.number().min(4, 'Minimum 4 heures par jour').max(12, 'Maximum 12 heures par jour').optional(),
    minHoursPerDay: z.number().min(1, 'Minimum 1 heure par jour').max(12, 'Maximum 12 heures par jour').optional(),
    mandatoryLunchBreak: z.boolean().optional(),
    lunchBreakDuration: z.number().min(30, 'Minimum 30 minutes de pause').max(120, 'Maximum 120 minutes de pause').optional()
  }).optional()
});

/**
 * Type TypeScript pour la requ√™te valid√©e
 */
type PlanningRequest = z.infer<typeof planningRequestSchema>;

/**
 * @route   POST /api/schedules/auto-generate
 * @desc    G√©n√®re automatiquement un planning hebdomadaire optimal
 * @access  Private (authentification requise)
 * @body    {PlanningRequest} Donn√©es de g√©n√©ration du planning
 * @returns {Object} Planning g√©n√©r√© ou erreur de validation
 */
router.post(
  '/auto-generate',
  authenticateToken,
  async (req: AuthRequest, res: Response) => {
    try {
      // Validation des donn√©es d'entr√©e avec Zod
      const validationResult = planningRequestSchema.safeParse(req.body);
      
      if (!validationResult.success) {
        // Formatage des erreurs de validation pour une r√©ponse claire
        const issues = validationResult.error.issues.map(issue => ({
          field: issue.path.join('.'),
          message: issue.message,
          code: issue.code
        }));
        
        return res.status(400).json({
          success: false,
          message: 'Param√®tres de g√©n√©ration invalides',
          issues
        });
      }
      
      // Extraction des donn√©es valid√©es
      const planningData: PlanningRequest = validationResult.data;
      
      // Validation m√©tier suppl√©mentaire
      if (planningData.employees.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'Aucun employ√© fourni pour la g√©n√©ration du planning'
        });
      }
      
      // V√©rification de la coh√©rence des dates d'exception
      const currentYear = planningData.year;
      for (const employee of planningData.employees) {
        if (employee.exceptions) {
          for (const exception of employee.exceptions) {
            const exceptionYear = parseInt(exception.date.split('-')[0]);
            if (exceptionYear !== currentYear) {
              return res.status(400).json({
                success: false,
                message: `Exception avec une ann√©e diff√©rente trouv√©e pour l'employ√© ${employee._id}`
              });
            }
          }
        }
      }
      
      // V√©rifier le cache pour chaque employ√© d'abord
      console.log(`üîç V√©rification du cache pour ${planningData.employees.length} employ√©(s)...`);
      const cachedPlannings: { [employeeId: string]: any } = {};
      const employeesToGenerate = [];

      for (const emp of planningData.employees) {
        const cacheKey = CacheHelpers.planningKey(emp._id, planningData.year, planningData.weekNumber);
        const cached = await cacheService.get(CacheKeyType.PLANNING_GENERATED, cacheKey);
        
        if (cached && cached.planning && cached.planning[emp._id]) {
          cachedPlannings[emp._id] = cached.planning[emp._id];
          console.log(`üíæ Cache HIT pour employ√© ${emp._id}`);
        } else {
          employeesToGenerate.push(emp);
          console.log(`üîç Cache MISS pour employ√© ${emp._id}`);
        }
      }

      let generatedPlanning: any = {};

      // Si tous les plannings sont en cache, les utiliser
      if (employeesToGenerate.length === 0) {
        console.log('üéØ Tous les plannings trouv√©s en cache !');
        generatedPlanning = cachedPlannings;
      } else {
        // G√©n√©rer seulement pour les employ√©s non cach√©s
        console.log(`‚ö° G√©n√©ration du planning pour ${employeesToGenerate.length} employ√©(s) non cach√©s...`);
        
        const newlyGenerated = generatePlanning({
          employees: employeesToGenerate.map(emp => ({
            _id: emp._id || '',
            contractHoursPerWeek: emp.contractHoursPerWeek || 35,
            exceptions: emp.exceptions?.map(exc => ({
              date: exc.date || '',
              type: exc.type || 'unavailable'
            })),
            preferences: emp.preferences
          })),
          weekNumber: planningData.weekNumber,
          year: planningData.year,
          companyConstraints: planningData.companyConstraints
        });

        // Combiner les plannings cach√©s et nouvellement g√©n√©r√©s
        generatedPlanning = { ...cachedPlannings, ...newlyGenerated };

        // Mettre en cache les nouveaux plannings
        for (const [employeeId, schedule] of Object.entries(newlyGenerated)) {
          const cacheKey = CacheHelpers.planningKey(employeeId, planningData.year, planningData.weekNumber);
          await cacheService.set(
            CacheKeyType.PLANNING_GENERATED,
            cacheKey,
            { planning: { [employeeId]: schedule } },
            CacheHelpers.getTTL(CacheKeyType.PLANNING_GENERATED)
          );
          console.log(`üíæ Mise en cache du planning pour employ√© ${employeeId}`);
        }
      }
      
      console.log('üéØ Planning g√©n√©r√© par le service:', JSON.stringify(generatedPlanning, null, 2));
      console.log('üìä Employ√©s dans le planning g√©n√©r√©:', Object.keys(generatedPlanning));
      
      // V√©rification que le planning a √©t√© g√©n√©r√©
      if (!generatedPlanning || Object.keys(generatedPlanning).length === 0) {
        console.log('‚ùå Planning g√©n√©r√© vide ou null');
        return res.status(500).json({
          success: false,
          message: 'Impossible de g√©n√©rer un planning avec les contraintes fournies'
        });
      }
      
      console.log('‚úÖ Planning g√©n√©r√© avec succ√®s, passage √† la sauvegarde...');
      
      // Calcul des statistiques du planning g√©n√©r√©
      const stats = calculatePlanningStats(generatedPlanning, planningData.employees);
      
      // Sauvegarde du planning en base de donn√©es pour chaque employ√©
      console.log('üíæ D√âBUT DE LA SAUVEGARDE...');
      console.log('üíæ Plannings √† sauvegarder:', Object.keys(generatedPlanning).length);
      
      const savedSchedules = [];
      for (const [employeeId, schedule] of Object.entries(generatedPlanning)) {
        console.log(`üíæ Traitement employ√©: ${employeeId}`);
        try {
          // Conversion du format de planning vers le format de la base de donn√©es
          const scheduleData: { [day: string]: { slots: string[] } } = {};
          
          for (const [day, slots] of Object.entries(schedule)) {
            if (slots && slots.length > 0) {
              scheduleData[day] = {
                slots: slots.map(slot => `${slot.start}-${slot.end}`)
              };
            }
          }
          
          // Validation de l'employeeId
          if (!mongoose.Types.ObjectId.isValid(employeeId)) {
            console.error(`ID employ√© invalide: ${employeeId}`);
            continue;
          }

          // Cr√©ation du document en base
          const generatedSchedule = new GeneratedScheduleModel({
            employeeId: new mongoose.Types.ObjectId(employeeId),
            scheduleData: scheduleData,
            generatedBy: req.user?.id || 'AI',
            timestamp: new Date(),
            status: 'draft',
            weekNumber: planningData.weekNumber,
            year: planningData.year
          });
          
          const savedSchedule = await generatedSchedule.save();
          savedSchedules.push(savedSchedule);
          
          console.log(`‚úÖ Planning sauvegard√© pour l'employ√© ${employeeId}:`, savedSchedule._id);
        } catch (saveError) {
          console.error(`‚ùå Erreur sauvegarde planning pour employ√© ${employeeId}:`, saveError);
          console.error('‚ùå Stack trace:', saveError instanceof Error ? saveError.stack : 'Stack trace non disponible');
        }
      }
      
      console.log(`${savedSchedules.length} plannings sauvegard√©s sur ${Object.keys(generatedPlanning).length}`);
      
      // R√©ponse de succ√®s avec le planning g√©n√©r√©
      return res.status(200).json({
        success: true,
        message: 'Planning g√©n√©r√© avec succ√®s',
        planning: generatedPlanning,
        savedSchedules: savedSchedules.length,
        metadata: {
          weekNumber: planningData.weekNumber,
          year: planningData.year,
          employeeCount: planningData.employees.length,
          generatedAt: new Date().toISOString(),
          stats
        }
      });
      
    } catch (error) {
      // Gestion des erreurs du service de g√©n√©ration
      console.error('Erreur lors de la g√©n√©ration automatique du planning:', error);
      
      return res.status(500).json({
        success: false,
        message: 'Erreur serveur lors de la g√©n√©ration du planning',
        error: process.env.NODE_ENV === 'development' ? (error as Error).message : 'Erreur interne'
      });
    }
  }
);

/**
 * Calcule les statistiques du planning g√©n√©r√©
 * @param planning Planning g√©n√©r√©
 * @param employees Liste des employ√©s
 * @returns Statistiques du planning
 */
function calculatePlanningStats(
  planning: { [employeeId: string]: { [day: string]: { start: string; end: string; }[]; } },
  employees: PlanningRequest['employees']
): {
  totalHoursPlanned: number;
  averageHoursPerEmployee: number;
  employeesWithFullSchedule: number;
  daysWithActivity: number;
} {
  let totalHoursPlanned = 0;
  let employeesWithFullSchedule = 0;
  const activeDays = new Set<string>();
  
  // Calcul des heures totales planifi√©es
  for (const [employeeId, schedule] of Object.entries(planning)) {
    let employeeHours = 0;
    
    for (const [day, slots] of Object.entries(schedule)) {
      if (slots.length > 0) {
        activeDays.add(day);
        
        for (const slot of slots) {
          // Calcul de la dur√©e du cr√©neau
          const [startHour, startMinute] = slot.start.split(':').map(Number);
          const [endHour, endMinute] = slot.end.split(':').map(Number);
          const startTime = startHour + startMinute / 60;
          const endTime = endHour + endMinute / 60;
          const slotDuration = endTime - startTime;
          
          employeeHours += slotDuration;
          totalHoursPlanned += slotDuration;
        }
      }
    }
    
    // V√©rification si l'employ√© a un planning complet
    const employee = employees.find(emp => emp._id === employeeId);
    if (employee && employeeHours >= employee.contractHoursPerWeek * 0.9) {
      employeesWithFullSchedule++;
    }
  }
  
  return {
    totalHoursPlanned: Math.round(totalHoursPlanned * 100) / 100,
    averageHoursPerEmployee: Math.round((totalHoursPlanned / employees.length) * 100) / 100,
    employeesWithFullSchedule,
    daysWithActivity: activeDays.size
  };
}


// Export du router pour utilisation dans l'application principale
export default router;